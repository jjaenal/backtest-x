import 'package:backtestx/models/trade.dart';
import 'package:backtestx/models/candle.dart';
import 'package:backtestx/core/data_manager.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:stacked/stacked.dart';
import 'package:stacked_services/stacked_services.dart';
import 'package:backtestx/app/app.locator.dart';
import 'package:csv/csv.dart';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
import 'dart:math';
import 'package:universal_html/html.dart' if (dart.library.html) 'dart:html'
    as html;
import 'package:backtestx/services/pdf_export_service.dart';

enum ChartMode { equity, drawdown }

class BacktestResultViewModel extends BaseViewModel {
  final BacktestResult result;
  final _snackbarService = locator<SnackbarService>();
  final _dataManager = DataManager();
  final _pdfExportService = PdfExportService();

  // Chart mode state
  ChartMode _chartMode = ChartMode.equity;
  ChartMode get chartMode => _chartMode;

  BacktestResultViewModel(this.result);

  // Method untuk mengubah chart mode
  void setChartMode(ChartMode mode) {
    _chartMode = mode;
    notifyListeners();
  }

  // Toggle chart mode
  void toggleChartMode() {
    _chartMode =
        _chartMode == ChartMode.equity ? ChartMode.drawdown : ChartMode.equity;
    notifyListeners();
  }

  // Properti tambahan untuk data yang tidak ada di BacktestResult
  String get strategyName => 'Strategy ${result.strategyId}';

  // Get market data info from DataManager
  MarketData? get marketData => _dataManager.getData(result.marketDataId);
  String get symbol => marketData?.symbol ?? 'Unknown';
  String get timeframe => marketData?.timeframe ?? 'Unknown';
  String get startDate =>
      marketData?.candles.first.timestamp.toString().split(' ')[0] ??
      result.executedAt.toString().split(' ')[0];
  String get endDate =>
      marketData?.candles.last.timestamp.toString().split(' ')[0] ??
      result.executedAt.toString().split(' ')[0];

  // Membuat teks ringkasan untuk dibagikan
  String _generateSummaryText() {
    final summary = result.summary;

    return '''
üìä Backtest Results - $strategyName

üí∞ Total PnL: \$${summary.totalPnl.toStringAsFixed(2)} (${summary.totalPnlPercentage.toStringAsFixed(2)}%)
üìà Win Rate: ${summary.winRate.toStringAsFixed(1)}% (${summary.winningTrades}/${summary.totalTrades})
üìâ Profit Factor: ${summary.profitFactor.toStringAsFixed(2)}
‚ö†Ô∏è Max Drawdown: ${summary.maxDrawdownPercentage.toStringAsFixed(1)}%
üìÜ Period: $startDate to $endDate
üîÑ Total Trades: ${summary.totalTrades}

Generated by BacktestX
    ''';
  }

  // Fungsi untuk membagikan hasil backtest
  Future<void> shareResults() async {
    final text = _generateSummaryText();

    try {
      if (kIsWeb) {
        // Untuk web, gunakan clipboard sebagai fallback utama
        await Clipboard.setData(ClipboardData(text: text));
        _snackbarService.showSnackbar(
          message: 'Results copied to clipboard!',
          duration: const Duration(seconds: 2),
        );
      } else {
        // Untuk mobile/desktop, gunakan Share package
        await Share.share(
          text,
          subject: 'BacktestX Results',
        );
        debugPrint('Shared successfully');
      }
    } catch (e) {
      // Fallback: Copy ke clipboard
      await Clipboard.setData(ClipboardData(text: text));
      debugPrint('error: $e');
      _snackbarService.showSnackbar(
        message: 'Results copied to clipboard!',
        duration: const Duration(seconds: 2),
      );
    }
  }

  // Copy summary ke clipboard secara eksplisit (tanpa share)
  Future<void> copySummaryToClipboard() async {
    final text = _generateSummaryText();
    try {
      await Clipboard.setData(ClipboardData(text: text));
      _snackbarService.showSnackbar(
        message: 'Summary copied to clipboard',
        duration: const Duration(seconds: 2),
      );
    } catch (e) {
      _snackbarService.showSnackbar(
        message: 'Copy failed: $e',
        duration: const Duration(seconds: 3),
      );
    }
  }

  // Copy trades table as CSV to clipboard
  Future<void> copyTradesCsvToClipboard() async {
    try {
      final closedTrades =
          result.trades.where((t) => t.status == TradeStatus.closed).toList();

      final List<List<dynamic>> rows = [];
      rows.add([
        'Direction',
        'Entry Date',
        'Exit Date',
        'Entry Price',
        'Exit Price',
        'Lot Size',
        'Stop Loss',
        'Take Profit',
        'PnL',
        'PnL %',
        'Duration',
      ]);

      for (final trade in closedTrades) {
        String duration = '-';
        if (trade.exitTime != null) {
          final diff = trade.exitTime!.difference(trade.entryTime).inHours;
          duration = '${diff ~/ 24}d ${diff % 24}h';
        }

        rows.add([
          trade.direction == TradeDirection.buy ? 'BUY' : 'SELL',
          trade.entryTime.toIso8601String(),
          trade.exitTime?.toIso8601String() ?? '-',
          trade.entryPrice.toStringAsFixed(4),
          trade.exitPrice?.toStringAsFixed(4) ?? '-',
          trade.lotSize.toStringAsFixed(2),
          trade.stopLoss?.toStringAsFixed(4) ?? '-',
          trade.takeProfit?.toStringAsFixed(4) ?? '-',
          trade.pnl?.toStringAsFixed(2) ?? '-',
          trade.pnlPercentage?.toStringAsFixed(2) ?? '-',
          duration,
        ]);
      }

      final csv = const ListToCsvConverter().convert(rows);
      await Clipboard.setData(ClipboardData(text: csv));
      _snackbarService.showSnackbar(
        message: 'Trades CSV copied to clipboard',
        duration: const Duration(seconds: 2),
      );
    } catch (e) {
      _snackbarService.showSnackbar(
        message: 'Copy failed: $e',
        duration: const Duration(seconds: 3),
      );
    }
  }

  // Fungsi untuk mengekspor hasil backtest ke CSV
  Future<void> exportResults() async {
    setBusy(true);

    try {
      // Membuat data untuk CSV
      final List<List<dynamic>> rows = [];

      // Header
      rows.add([
        'Strategy',
        'Symbol',
        'Timeframe',
        'Direction',
        'Entry Date',
        'Exit Date',
        'Entry Price',
        'Exit Price',
        'PnL',
        'PnL %',
        'Duration'
      ]);

      // Data trades
      for (final trade in result.trades) {
        // Hitung durasi dalam hari jika exitTime tersedia
        String duration = '-';
        if (trade.exitTime != null) {
          final diff = trade.exitTime!.difference(trade.entryTime).inHours;
          duration = '${diff ~/ 24}d ${diff % 24}h';
        }

        rows.add([
          strategyName,
          symbol,
          timeframe,
          trade.direction == TradeDirection.buy ? 'BUY' : 'SELL',
          trade.entryTime.toString(),
          trade.exitTime?.toString() ?? '-',
          trade.entryPrice.toStringAsFixed(2),
          trade.exitPrice?.toStringAsFixed(2) ?? '-',
          trade.pnl?.toStringAsFixed(2) ?? '-',
          trade.pnlPercentage?.toStringAsFixed(2) ?? '-',
          duration
        ]);
      }

      // Konversi ke CSV
      String csv = const ListToCsvConverter().convert(rows);

      // Simpan file CSV dan bagikan
      final fileName = '${strategyName}_backtest_results.csv';

      // Gunakan pendekatan yang berbeda berdasarkan platform
      try {
        // Untuk web, gunakan universal_html
        if (kIsWeb) {
          _saveFileForWeb(csv, fileName);
        } else {
          // Untuk mobile/desktop, gunakan path_provider dan share_plus
          await _saveFileForMobile(csv, fileName);
        }

        _snackbarService.showSnackbar(
          message: 'Results exported to CSV',
          duration: const Duration(seconds: 2),
        );
      } catch (e) {
        _snackbarService.showSnackbar(
          message: 'Export failed: $e',
          duration: const Duration(seconds: 3),
        );
      }
    } catch (e) {
      _snackbarService.showSnackbar(
        message: 'Export failed: $e',
        duration: const Duration(seconds: 3),
      );
    } finally {
      setBusy(false);
    }
  }

  // Ekspor hasil backtest ke PDF
  Future<void> exportPdf() async {
    setBusy(true);
    try {
      final bytes = await _pdfExportService.buildBacktestReport(result);
      final fileName = '${strategyName}_backtest_report.pdf';

      if (kIsWeb) {
        final blob = html.Blob([bytes], 'application/pdf');
        final url = html.Url.createObjectUrlFromBlob(blob);
        final anchor = html.AnchorElement(href: url)
          ..setAttribute('download', fileName)
          ..click();
        if (anchor.href!.isNotEmpty) {
          html.Url.revokeObjectUrl(url);
        }
      } else {
        final directory = await getApplicationDocumentsDirectory();
        final path = '${directory.path}/$fileName';
        final file = File(path);
        await file.writeAsBytes(bytes, flush: true);
        await Share.shareXFiles([XFile(path)], text: 'BacktestX PDF Report');
      }

      _snackbarService.showSnackbar(
        message: 'PDF exported successfully',
        duration: const Duration(seconds: 2),
      );
    } catch (e) {
      _snackbarService.showSnackbar(
        message: 'Export PDF failed: $e',
        duration: const Duration(seconds: 3),
      );
    } finally {
      setBusy(false);
    }
  }

  void _saveFileForWeb(String csv, String fileName) {
    // Implementasi untuk web menggunakan universal_html
    final blob = html.Blob([csv], 'text/csv');
    final url = html.Url.createObjectUrlFromBlob(blob);
    final anchor = html.AnchorElement(href: url)
      ..setAttribute('download', fileName)
      ..click();
    if (anchor.href != null) {
      html.Url.revokeObjectUrl(url);
    }
  }

  Future<void> _saveFileForMobile(String csv, String fileName) async {
    // Implementasi untuk mobile/desktop
    final directory = await getApplicationDocumentsDirectory();
    final path = '${directory.path}/$fileName';
    final file = File(path);
    await file.writeAsString(csv);
    await Share.shareXFiles([XFile(path)], text: 'BacktestX Results');
  }

  String getTradeDirectionLabel(TradeDirection direction) {
    return direction == TradeDirection.buy ? 'BUY' : 'SELL';
  }

  String formatPnL(double? pnl) {
    if (pnl == null) return '-';
    return '\$${pnl.toStringAsFixed(2)}';
  }

  String formatPercentage(double? percentage) {
    if (percentage == null) return '-';
    return '${percentage >= 0 ? '+' : ''}${percentage.toStringAsFixed(2)}%';
  }

  /// Generate demo candles for candlestick chart
  List<Candle> getCandles() {
    // Try to get actual market data first
    final actualMarketData = _dataManager.getData(result.marketDataId);
    if (actualMarketData != null && actualMarketData.candles.isNotEmpty) {
      // Optimize chart rendering for very large datasets by downsampling
      final candles = actualMarketData.candles;
      const targetPoints = 1500; // target render points for smooth performance
      if (candles.length <= targetPoints) {
        return candles;
      }
      final stride = (candles.length / targetPoints).ceil();
      final downsampled = <Candle>[];
      for (int i = 0; i < candles.length; i += stride) {
        downsampled.add(candles[i]);
      }
      // Ensure last candle is included for accurate last price/marker
      if (downsampled.isEmpty || downsampled.last.timestamp != candles.last.timestamp) {
        downsampled.add(candles.last);
      }
      return downsampled;
    }

    // Fallback to demo data if market data not available
    final random = Random();
    final candles = <Candle>[];
    double price = 100.0;
    final now = DateTime.now();

    for (int i = 0; i < 100; i++) {
      final timestamp = now.subtract(Duration(days: 100 - i));
      final change = (random.nextDouble() - 0.5) * 4; // -2 to +2
      price += change;

      final high = price + random.nextDouble() * 2;
      final low = price - random.nextDouble() * 2;
      final open = low + random.nextDouble() * (high - low);
      final close = low + random.nextDouble() * (high - low);

      candles.add(Candle(
        timestamp: timestamp,
        open: open,
        high: high,
        low: low,
        close: close,
        volume: random.nextDouble() * 1000000,
      ));
    }

    return candles;
  }
}
