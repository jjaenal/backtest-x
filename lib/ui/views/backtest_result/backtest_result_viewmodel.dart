import 'package:backtestx/app/app.locator.dart';
import 'package:backtestx/models/trade.dart';
import 'package:backtestx/models/strategy.dart';
import 'package:backtestx/services/storage_service.dart';
import 'package:stacked/stacked.dart';
import 'package:stacked_services/stacked_services.dart';

enum TradeFilter { all, wins, losses }

class BacktestResultViewModel extends BaseViewModel {
  final _storageService = locator<StorageService>();
  final _snackbarService = locator<SnackbarService>();

  final String? resultId;

  BacktestResultViewModel(this.resultId);

  BacktestResult? result;
  Strategy? strategy;
  bool showDrawdown = false;
  TradeFilter tradeFilter = TradeFilter.all;

  String get strategyName => strategy?.name ?? 'Unknown Strategy';

  List<Trade> get filteredTrades {
    if (result == null) return [];

    switch (tradeFilter) {
      case TradeFilter.all:
        return result!.trades;
      case TradeFilter.wins:
        return result!.trades.where((t) => (t.pnl ?? 0) > 0).toList();
      case TradeFilter.losses:
        return result!.trades.where((t) => (t.pnl ?? 0) < 0).toList();
    }
  }

  Future<void> initialize() async {
    setBusy(true);

    if (resultId != null) {
      await _loadResult(resultId!);
    } else {
      // Load most recent result
      await _loadMostRecentResult();
    }

    setBusy(false);
  }

  Future<void> _loadResult(String id) async {
    try {
      result = await _storageService.getBacktestResult(id);

      if (result != null) {
        strategy = await _storageService.getStrategy(result!.strategyId);
      }

      notifyListeners();
    } catch (e) {
      print('Error loading result: $e');
      _snackbarService.showSnackbar(
        message: 'Failed to load result',
        duration: const Duration(seconds: 3),
      );
    }
  }

  Future<void> _loadMostRecentResult() async {
    try {
      final strategies = await _storageService.getAllStrategies();

      if (strategies.isEmpty) return;

      // Get most recent strategy's most recent result
      for (final strat in strategies) {
        final results =
            await _storageService.getBacktestResultsByStrategy(strat.id);
        if (results.isNotEmpty) {
          result = results.first;
          strategy = strat;
          notifyListeners();
          return;
        }
      }
    } catch (e) {
      print('Error loading recent result: $e');
    }
  }

  void toggleDrawdown() {
    showDrawdown = !showDrawdown;
    notifyListeners();
  }

  void setTradeFilter(TradeFilter filter) {
    tradeFilter = filter;
    notifyListeners();
  }

  Future<void> shareResults() async {
    if (result == null) return;

    final summary = result!.summary;
    final text = '''
üìä Backtest Results - ${strategyName}

üí∞ Total PnL: \$${summary.totalPnl.toStringAsFixed(2)} (${summary.totalPnlPercentage.toStringAsFixed(2)}%)
üìà Win Rate: ${summary.winRate.toStringAsFixed(1)}% (${summary.winningTrades}/${summary.totalTrades})
üìâ Profit Factor: ${summary.profitFactor.toStringAsFixed(2)}
‚ö†Ô∏è  Max Drawdown: ${summary.maxDrawdownPercentage.toStringAsFixed(1)}%

Generated by Backtest Pro
    ''';

    // TODO: Implement share functionality
    _snackbarService.showSnackbar(
      message: 'Share functionality coming soon!',
      duration: const Duration(seconds: 2),
    );

    print(text);
  }

  Future<void> exportResults() async {
    if (result == null) return;

    try {
      // TODO: Implement CSV export
      _snackbarService.showSnackbar(
        message: 'Export functionality coming soon!',
        duration: const Duration(seconds: 2),
      );
    } catch (e) {
      _snackbarService.showSnackbar(
        message: 'Export failed: $e',
        duration: const Duration(seconds: 3),
      );
    }
  }
}
