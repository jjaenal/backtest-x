import 'package:backtestx/app/app.locator.dart';
import 'package:backtestx/helpers/backtest_helper.dart';
import 'package:backtestx/models/trade.dart';
import 'package:backtestx/models/strategy.dart';
import 'package:backtestx/services/storage_service.dart';
import 'package:flutter/material.dart';
import 'package:stacked/stacked.dart';
import 'package:stacked_services/stacked_services.dart';

enum TradeFilter { all, wins, losses }

class BacktestResultViewModel extends BaseViewModel {
  final _storageService = locator<StorageService>();
  final _snackbarService = locator<SnackbarService>();

  final String? resultId;

  BacktestResultViewModel(this.resultId);

  BacktestResult? result;
  Strategy? strategy;
  bool showDrawdown = false;
  TradeFilter tradeFilter = TradeFilter.all;

  String get strategyName => strategy?.name ?? 'Unknown Strategy';

  List<Trade> get filteredTrades {
    if (result == null) return [];

    switch (tradeFilter) {
      case TradeFilter.all:
        return result!.trades;
      case TradeFilter.wins:
        return result!.trades.where((t) => (t.pnl ?? 0) > 0).toList();
      case TradeFilter.losses:
        return result!.trades.where((t) => (t.pnl ?? 0) < 0).toList();
    }
  }

  Future<void> initialize() async {
    setBusy(true);

    if (resultId != null) {
      await _loadResult(resultId!);
    } else {
      // Load most recent result
      await _loadMostRecentResult();
    }

    setBusy(false);
  }

  Future<void> _loadResult(String id) async {
    try {
      debugPrint('\nüìä Loading result: $id');

      // Try to get from cache first (has full data)
      result = ResultCache.get(id);

      if (result != null) {
        debugPrint('‚úÖ Loaded from cache (full data)');
        debugPrint('   Trades: ${result!.trades.length}');
        debugPrint('   Equity points: ${result!.equityCurve.length}');
      } else {
        debugPrint('‚ö†Ô∏è  Not in cache, loading from database (summary only)');
        // Load from database (summary only, no trades/equity)
        result = await _storageService.getBacktestResult(id);

        if (result != null) {
          debugPrint('‚úÖ Loaded from database');
          debugPrint('   Note: Trades and equity curve not available from DB');
          debugPrint('   To see full details, re-run the backtest');
        }
      }

      if (result != null) {
        strategy = await _storageService.getStrategy(result!.strategyId);
      }

      notifyListeners();
    } catch (e) {
      debugPrint('Error loading result: $e');
      _snackbarService.showSnackbar(
        message: 'Failed to load result',
        duration: const Duration(seconds: 3),
      );
    }
  }

  Future<void> _loadMostRecentResult() async {
    try {
      debugPrint('\nüìä Loading most recent result...');

      final strategies = await _storageService.getAllStrategies();

      if (strategies.isEmpty) {
        debugPrint('‚ö†Ô∏è  No strategies found');
        return;
      }

      // Get most recent strategy's most recent result
      for (final strat in strategies) {
        final results =
            await _storageService.getBacktestResultsByStrategy(strat.id);
        if (results.isNotEmpty) {
          final latestResult = results.first;

          // Try cache first
          result = ResultCache.get(latestResult.id);

          if (result == null) {
            debugPrint('‚ö†Ô∏è  Latest result not in cache, using summary only');
            result = latestResult;
          } else {
            debugPrint('‚úÖ Found latest result in cache');
          }

          strategy = strat;
          notifyListeners();
          return;
        }
      }

      debugPrint('‚ö†Ô∏è  No results found');
    } catch (e) {
      debugPrint('Error loading recent result: $e');
    }
  }

  void toggleDrawdown() {
    showDrawdown = !showDrawdown;
    notifyListeners();
  }

  void setTradeFilter(TradeFilter filter) {
    tradeFilter = filter;
    notifyListeners();
  }

  Future<void> shareResults() async {
    if (result == null) return;

    final summary = result!.summary;
    final text = '''
üìä Backtest Results - $strategyName

üí∞ Total PnL: \${summary.totalPnl.toStringAsFixed(2)} (${summary.totalPnlPercentage.toStringAsFixed(2)}%)
üìà Win Rate: ${summary.winRate.toStringAsFixed(1)}% (${summary.winningTrades}/${summary.totalTrades})
üìâ Profit Factor: ${summary.profitFactor.toStringAsFixed(2)}
‚ö†Ô∏è  Max Drawdown: ${summary.maxDrawdownPercentage.toStringAsFixed(1)}%

Generated by Backtest Pro
    ''';
    _snackbarService.showSnackbar(
      message: 'Share functionality coming soon!',
      duration: const Duration(seconds: 2),
    );

    debugPrint(text);
  }

  Future<void> exportResults() async {
    if (result == null) return;

    try {
      _snackbarService.showSnackbar(
        message: 'Export functionality coming soon!',
        duration: const Duration(seconds: 2),
      );
    } catch (e) {
      _snackbarService.showSnackbar(
        message: 'Export failed: $e',
        duration: const Duration(seconds: 3),
      );
    }
  }
}
